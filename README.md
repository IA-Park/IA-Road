# IA-Road

A repository to define the road to learn all about AI

**Módulo 1. Fundamentos de la Inteligencia Artificial**

- 1.1. Historia de la Inteligencia artificial
  - 1.1.1. ¿Cuándo se empieza a hablar de inteligencia artificial?
  - 1.1.2. Referentes en el cine
  - 1.1.3. Importancia de la inteligencia artificial
  - 1.1.4. Tecnologías que habilitan y dan soporte a la inteligencia artificial
- 1.2. La Inteligencia Artificial en juegos
  - 1.2.1. Teoría de Juegos
  - 1.2.2. Minimax y poda Alfa-Beta
  - 1.2.3. Simulación: Monte Carlo
- 1.3. Redes de neuronas
  - 1.3.1. Fundamentos biológicos
  - 1.3.2. Modelo computacional
  - 1.3.3. Redes de neuronas supervisadas y no supervisadas
  - 1.3.4. Perceptrón simple
  - 1.3.5. Perceptrón multicapa
- 1.4. Algoritmos genéticos
  - 1.4.1. Historia
  - 1.4.2. Base biológica
  - 1.4.3. Codificación de problemas
  - 1.4.4. Generación de la población inicial
  - 1.4.5. Algoritmo principal y operadores genéticos
  - 1.4.6. Evaluación de individuos: Fitness
- 1.5. Tesauros, vocabularios, taxonomías
  - 1.5.1. Vocabularios
  - 1.5.2. Taxonomías
  - 1.5.3. Tesauros
  - 1.5.4. Ontologías
  - 1.5.5. Representación del conocimiento: web semántica
- 1.6. Web semántica
  - 1.6.1. Especificaciones: RDF, RDFS y OWL
  - 1.6.2. Inferencia/razonamiento
  - 1.6.3. Linked Data
- 1.7. Sistemas expertos y DSS
  - 1.7.1. Sistemas expertos
  - 1.7.2. Sistemas de soporte a la decisión
- 1.8. Chatbots y Asistentes Virtuales
  - 1.8.1. Tipos de asistentes: asistentes por voz y por texto
  - 1.8.2. Partes fundamentales para el desarrollo de un asistente: Intents, entidades y flujo de diálogo
  - 1.8.3. Integraciones: web, Slack, Whatsapp, Facebook
  - 1.8.4. Herramientas de desarrollo de asistentes: Dialog Flow, Watson Assistant
- 1.9. Estrategia de implantación de IA
- 1.10. Futuro de la inteligencia artificial
  - 1.10.1. Entendemos cómo detectar emociones mediante algoritmos
  - 1.10.2. Creación de una personalidad: lenguaje, expresiones y contenido
  - 1.10.3. Tendencias de la inteligencia artificial
  - 1.10.4. Reflexiones

**Módulo 2. Tipos y Ciclo de Vida del Dato**

- 2.1. La Estadística
  - 2.1.1. Estadística: estadística descriptiva, estadística inferencias
  - 2.1.2. Población, muestra, individuo
  - 2.1.3. Variables: definición, escalas de medida
- 2.2. Tipos de datos estadísticos
  - 2.2.1. Según tipo
    - 2.2.1.1. Cuantitativos: datos continuos y datos discretos
    - 2.2.1.2. Cualitativos: datos binomiales, datos nominales y datos ordinales
  - 2.2.2. Según su forma
    - 2.2.2.1. Numérico
    - 2.2.2.2. Texto
    - 2.2.2.3. Lógico
  - 2.2.3. Según su fuente
    - 2.2.3.1. Primarios
    - 2.2.3.2. Secundarios
- 2.3. Ciclo de vida de los datos
  - 2.3.1. Etapas del ciclo
  - 2.3.2. Hitos del ciclo
  - 2.3.3. Principios FAIR
- 2.4. Etapas iniciales del ciclo
  - 2.4.1. Definición de metas
  - 2.4.2. Determinación de recursos necesarios
  - 2.4.3. Diagrama de Gantt
  - 2.4.4. Estructura de los datos
- 2.5. Recolección de datos
  - 2.5.1. Metodología de recolección
  - 2.5.2. Herramientas de recolección
  - 2.5.3. Canales de recolección
- 2.6. Limpieza del dato
  - 2.6.1. Fases de la limpieza de datos
  - 2.6.2. Calidad del dato
  - 2.6.3. Manipulación de datos (con R)
- 2.7. Análisis de datos, interpretación y valoración de resultados
  - 2.7.1. Medidas estadísticas
  - 2.7.2. Índices de relación
  - 2.7.3. Minería de datos
- 2.8. Almacén del dato (Datawarehouse)
  - 2.8.1. Elementos que lo integran
  - 2.8.2. Diseño
  - 2.8.3. Aspectos a considerar
- 2.9. Disponibilidad del dato
  - 2.9.1. Acceso
  - 2.9.2. Utilidad
  - 2.9.3. Seguridad
- 2.10. Aspectos Normativos
  - 2.10.1. Ley de protección de datos
  - 2.10.2. Buenas prácticas
  - 2.10.3. Otros aspectos normativos

**Módulo 3. El dato en la Inteligencia Artificial**

- 3.1. Ciencia de datos
  - 3.1.1. La ciencia de datos
  - 3.1.2. Herramientas avanzadas para el científico de datos
- 3.2. Datos, información y conocimiento
  - 3.2.1. Datos, información y conocimiento
  - 3.2.2. Tipos de datos
  - 3.2.3. Fuentes de datos
- 3.3. De los datos a la información
  - 3.3.1. Análisis de Datos
  - 3.3.2. Tipos de análisis
  - 3.3.3. Extracción de Información de un Dataset
- 3.4. Extracción de información mediante visualización
  - 3.4.1. La visualización como herramienta de análisis
  - 3.4.2. Métodos de visualización
  - 3.4.3. Visualización de un conjunto de datos
- 3.5. Calidad de los datos
  - 3.5.1. Datos de calidad
  - 3.5.2. Limpieza de datos
  - 3.5.3. Preprocesamiento básico de datos
- 3.6. Dataset
  - 3.6.1. Enriquecimiento del Dataset
  - 3.6.2. La maldición de la dimensionalidad
  - 3.6.3. Modificación de nuestro conjunto de datos
- 3.7. Desbalanceo
  - 3.7.1. Desbalanceo de clases
  - 3.7.2. Técnicas de mitigación del desbalanceo
  - 3.7.3. Balanceo de un Dataset
- 3.8. Modelos no supervisados
  - 3.8.1. Modelo no supervisado
  - 3.8.2. Métodos
  - 3.8.3. Clasificación con modelos no supervisados
- 3.9. Modelos supervisados
  - 3.9.1. Modelo supervisado
  - 3.9.2. Métodos
  - 3.9.3. Clasificación con modelos supervisados
- 3.10. Herramientas y buenas prácticas
  - 3.10.1. Buenas prácticas para un científico de datos
  - 3.10.2. El mejor modelo
  - 3.10.3. Herramientas útiles

Módulo 4. Minería de Datos. Selección, preprocesamiento y transformación
4.1. La inferencia estadística
4.1.1. Estadística descriptiva vs. Inferencia estadística
4.1.2. Procedimientos paramétricos
4.1.3. Procedimientos no paramétricos
4.2. Análisis exploratorio
4.2.1. Análisis descriptivo
4.2.2. Visualización
4.2.3. Preparación de datos
4.3. Preparación de datos
4.3.1. Integración y limpieza de datos
4.3.2. Normalización de datos
4.3.3. Transformando atributos
4.4. Los valores perdidos
4.4.1. Tratamiento de valores perdidos
4.4.2. Métodos de imputación de máxima verosimilitud
4.4.3. Imputación de valores perdidos usando aprendizaje automático
4.5. El ruido en los datos
4.5.1. Clases de ruido y atributos
4.5.2. Filtrado de ruido
4.5.3. El efecto del ruido
4.6. La maldición de la dimensionalidad
4.6.1. Oversampling
4.6.2. Undersampling
4.6.3. Reducción de datos multidimensionales
4.7. De atributos continuos a discretos
4.7.1. Datos continuos versus discretos
4.7.2. Proceso de discretización
4.8. Los datos
4.8.1. Selección de datos
4.8.2. Perspectivas y criterios de selección
4.8.3. Métodos de selección
4.9. Selección de instancias
4.9.1. Métodos para la selección de instancias
4.9.2. Selección de prototipos
4.9.3. Métodos avanzados para la selección de instancias
4.10. Preprocesamiento de datos en entornos Big Data
Módulo 5. Algoritmia y complejidad en Inteligencia Artificial
5.1. Introducción a las estrategias de diseño de algoritmos
5.1.1. Recursividad
5.1.2. Divide y conquista
5.1.3. Otras estrategias
5.2. Eficiencia y análisis de los algoritmos
5.2.1. Medidas de eficiencia
5.2.2. Medir el tamaño de la entrada
5.2.3. Medir el tiempo de ejecución
5.2.4. Caso peor, mejor y medio
5.2.5. Notación asintónica
5.2.6. Criterios de Análisis matemático de algoritmos no recursivos
5.2.7. Análisis matemático de algoritmos recursivos
5.2.8. Análisis empírico de algoritmos
5.3. Algoritmos de ordenación
5.3.1. Concepto de ordenación
5.3.2. Ordenación de la burbuja
5.3.3. Ordenación por selección
5.3.4. Ordenación por inserción
5.3.5. Ordenación por mezcla (Merge_Sort)
5.3.6. Ordenación rápida (Quick_Sort)
5.4. Algoritmos con árboles
5.4.1. Concepto de árbol
5.4.2. Árboles binarios
5.4.3. Recorridos de árbol
5.4.4. Representar expresiones
5.4.5. Árboles binarios ordenados
5.4.6. Árboles binarios balanceados
5.5. Algoritmos con Heaps
5.5.1. Los Heaps
5.5.2. El algoritmo Heapsort
5.5.3. Las colas de prioridad
5.6. Algoritmos con grafos
5.6.1. Representación
5.6.2. Recorrido en anchura
5.6.3. Recorrido en profundidad
5.6.4. Ordenación topológica
5.7. Algoritmos Greedy
5.7.1. La estrategia Greedy
5.7.2. Elementos de la estrategia Greedy
5.7.3. Cambio de monedas
5.7.4. Problema del viajante
5.7.5. Problema de la mochila
5.8. Búsqueda de caminos mínimos
5.8.1. El problema del camino mínimo
5.8.2. Arcos negativos y ciclos
5.8.3. Algoritmo de Dijkstra
5.9. Algoritmos Greedy sobre grafos
5.9.1. El árbol de recubrimiento mínimo
5.9.2. El algoritmo de Prim
5.9.3. El algoritmo de Kruskal
5.9.4. Análisis de complejidad
5.10. Backtracking
5.10.1. El Backtracking
5.10.2. Técnicas alternativas
Módulo 6. Sistemas inteligentes
6.1. Teoría de agentes
6.1.1. Historia del concepto
6.1.2. Definición de agente
6.1.3. Agentes en Inteligencia Artificial
6.1.4. Agentes en ingeniería de Software
6.2. Arquitecturas de agentes
6.2.1. El proceso de razonamiento de un agente
6.2.2. Agentes reactivos
6.2.3. Agentes deductivos
6.2.4. Agentes híbridos
6.2.5. Comparativa
6.3. Información y conocimiento
6.3.1. Distinción entre datos, información y conocimiento
6.3.2. Evaluación de la calidad de los datos
6.3.3. Métodos de captura de datos
6.3.4. Métodos de adquisición de información
6.3.5. Métodos de adquisición de conocimiento
6.4. Representación del conocimiento
6.4.1. La importancia de la representación del conocimiento
6.4.2. Definición de representación del conocimiento a través de sus roles
6.4.3. Características de una representación del conocimiento
6.5. Ontologías
6.5.1. Introducción a los metadatos
6.5.2. Concepto filosófico de ontología
6.5.3. Concepto informático de ontología
6.5.4. Ontologías de dominio y ontologías de nivel superior
6.5.5. ¿Cómo construir una ontología?
6.6. Lenguajes para ontologías y Software para la creación de ontologías
6.6.1. Tripletas RDF, Turtle y N
6.6.2. RDF Schema
6.6.3. OWL
6.6.4. SPARQL
6.6.5. Introducción a las diferentes herramientas para la creación de ontologías
6.6.6. Instalación y uso de Protégé
6.7. La web semántica
6.7.1. El estado actual y futuro de la web semántica
6.7.2. Aplicaciones de la web semántica
6.8. Otros modelos de representación del conocimiento
6.8.1. Vocabularios
6.8.2. Visión global
6.8.3. Taxonomías
6.8.4. Tesauros
6.8.5. Folksonomías
6.8.6. Comparativa
6.8.7. Mapas mentales
6.9. Evaluación e integración de representaciones del conocimiento
6.9.1. Lógica de orden cero
6.9.2. Lógica de primer orden
6.9.3. Lógica descriptiva
6.9.4. Relación entre diferentes tipos de lógica
6.9.5. Prolog: programación basada en lógica de primer orden
6.10. Razonadores semánticos, sistemas basados en conocimiento y Sistemas Expertos
6.10.1. Concepto de razonador
6.10.2. Aplicaciones de un razonador
6.10.3. Sistemas basados en el conocimiento
6.10.4. MYCIN, historia de los Sistemas Expertos
6.10.5. Elementos y Arquitectura de Sistemas Expertos
6.10.6. Creación de Sistemas Expertos
Módulo 7. Aprendizaje automático y minería de datos
7.1. Introducción a los procesos de descubrimiento del conocimiento y conceptos básicos
de aprendizaje automático
7.1.1. Conceptos clave de los procesos de descubrimiento del conocimiento
7.1.2. Perspectiva histórica de los procesos de descubrimiento del conocimiento
7.1.3. Etapas de los procesos de descubrimiento del conocimiento
7.1.4. Técnicas utilizadas en los procesos de descubrimiento del conocimiento
7.1.5. Características de los buenos modelos de aprendizaje automático
7.1.6. Tipos de información de aprendizaje automático
7.1.7. Conceptos básicos de aprendizaje
7.1.8. Conceptos básicos de aprendizaje no supervisado
7.2. Exploración y preprocesamiento de datos
7.2.1. Tratamiento de datos
7.2.2. Tratamiento de datos en el flujo de análisis de datos
7.2.3. Tipos de datos
7.2.4. Transformaciones de datos
7.2.5. Visualización y exploración de variables continuas
7.2.6. Visualización y exploración de variables categóricas
7.2.7. Medidas de correlación
7.2.8. Representaciones gráficas más habituales
7.2.9. Introducción al análisis multivariante y a la reducción de dimensiones
7.3. Árboles de decisión
7.3.1. Algoritmo ID
7.3.2. Algoritmo C
7.3.3. Sobreentrenamiento y poda
7.3.4. Análisis de resultados
7.4. Evaluación de clasificadores
7.4.1. Matrices de confusión
7.4.2. Matrices de evaluación numérica
7.4.3. Estadístico de Kappa
7.4.4. La curva ROC
7.5. Reglas de clasificación
7.5.1. Medidas de evaluación de reglas
7.5.2. Introducción a la representación gráfica
7.5.3. Algoritmo de recubrimiento secuencial
7.6. Redes neuronales
7.6.1. Conceptos básicos
7.6.2. Redes de neuronas simples
7.6.3. Algoritmo de Backpropagation
7.6.4. Introducción a las redes neuronales recurrentes
7.7. Métodos bayesianos
7.7.1. Conceptos básicos de probabilidad
7.7.2. Teorema de Bayes
7.7.3. Naive Bayes
7.7.4. Introducción a las redes bayesianas
7.8. Modelos de regresión y de respuesta continua
7.8.1. Regresión lineal simple
7.8.2. Regresión lineal múltiple
7.8.3. Regresión logística
7.8.4. Árboles de regresión
7.8.5. Introducción a las máquinas de soporte vectorial (SVM)
7.8.6. Medidas de bondad de ajuste
7.9. Clustering
7.9.1. Conceptos básicos
7.9.2. Clustering jerárquico
7.9.3. Métodos probabilistas
7.9.4. Algoritmo EM
7.9.5. Método B-Cubed
7.9.6. Métodos implícitos
7.10. Minería de textos y procesamiento de lenguaje natural (NLP)
7.10.1. Conceptos básicos
7.10.2. Creación del corpus
7.10.3. Análisis descriptivo
7.10.4. Introducción al análisis de sentimientos
Módulo 8. Las redes neuronales, base de Deep Learning
8.1. Aprendizaje Profundo
8.1.1. Tipos de aprendizaje profundo
8.1.2. Aplicaciones del aprendizaje profundo
8.1.3. Ventajas y desventajas del aprendizaje profundo
8.2. Operaciones
8.2.1. Suma
8.2.2. Producto
8.2.3. Traslado
8.3. Capas
8.3.1. Capa de entrada
8.3.2. Capa oculta
8.3.3. Capa de salida
8.4. Unión de Capas y Operaciones
8.4.1. Diseño de arquitecturas
8.4.2. Conexión entre capas
8.4.3. Propagación hacia adelante
8.5. Construcción de la primera red neuronal
8.5.1. Diseño de la red
8.5.2. Establecer los pesos
8.5.3. Entrenamiento de la red
8.6. Entrenador y Optimizador
8.6.1. Selección del optimizador
8.6.2. Establecimiento de una función de pérdida
8.6.3. Establecimiento de una métrica
8.7. Aplicación de los Principios de las Redes Neuronales
8.7.1. Funciones de activación
8.7.2. Propagación hacia atrás
8.7.3. Ajuste de los parámetros
8.8. De las neuronas biológicas a las artificiales
8.8.1. Funcionamiento de una neurona biológica
8.8.2. Transferencia de conocimiento a las neuronas artificiales
8.8.3. Establecer relaciones entre ambas
8.9. Implementación de MLP (Perceptrón multicapa) con Keras
8.9.1. Definición de la estructura de la red
8.9.2. Compilación del modelo
8.9.3. Entrenamiento del modelo
8.10. Hiperparámetros de Fine tuning de Redes Neuronales
8.10.1. Selección de la función de activación
8.10.2. Establecer el Learning rate
8.10.3. Ajuste de los pesos
Módulo 9. Entrenamiento de redes neuronales profundas
9.1. Problemas de Gradientes
9.1.1. Técnicas de optimización de gradiente
9.1.2. Gradientes Estocásticos
9.1.3. Técnicas de inicialización de pesos
9.2. Reutilización de capas preentrenadas
9.2.1. Entrenamiento de transferencia de aprendizaje
9.2.2. Extracción de características
9.2.3. Aprendizaje profundo
9.3. Optimizadores
9.3.1. Optimizadores de descenso de gradiente estocástico
9.3.2. Optimizadores Adam y RMSprop
9.3.3. Optimizadores de momento
9.4. Programación de la tasa de aprendizaje
9.4.1. Control de tasa de aprendizaje automático
9.4.2. Ciclos de aprendizaje
9.4.3. Términos de suavizado
9.5. Sobreajuste
9.5.1. Validación cruzada
9.5.2. Regularización
9.5.3. Métricas de evaluación
9.6. Directrices Prácticas
9.6.1. Diseño de modelos
9.6.2. Selección de métricas y parámetros de evaluación
9.6.3. Pruebas de hipótesis
9.7. Transfer Learning
9.7.1. Entrenamiento de transferencia de aprendizaje
9.7.2. Extracción de características
9.7.3. Aprendizaje profundo
9.8. Data Augmentation
9.8.1. Transformaciones de imagen
9.8.2. Generación de datos sintéticos
9.8.3. Transformación de texto
9.9. Aplicación Práctica de Transfer Learning
9.9.1. Entrenamiento de transferencia de aprendizaje
9.9.2. Extracción de características
9.9.3. Aprendizaje profundo
9.10. Regularización
9.10.1. L y L
9.10.2. Regularización por máxima entropía
9.10.3. Dropout
Módulo 10. Personalización de Modelos y entrenamiento con TensorFlow
10.1. TensorFlow
10.1.1. Uso de la biblioteca TensorFlow
10.1.2. Entrenamiento de modelos con TensorFlow
10.1.3. Operaciones con gráficos en TensorFlow
10.2. TensorFlow y NumPy
10.2.1. Entorno computacional NumPy para TensorFlow
10.2.2. Utilización de los arrays NumPy con TensorFlow
10.2.3. Operaciones NumPy para los gráficos de TensorFlow
10.3. Personalización de modelos y algoritmos de entrenamiento
10.3.1. Construcción de modelos personalizados con TensorFlow
10.3.2. Gestión de parámetros de entrenamiento
10.3.3. Utilización de técnicas de optimización para el entrenamiento
10.4. Funciones y gráficos de TensorFlow
10.4.1. Funciones con TensorFlow
10.4.2. Utilización de gráficos para el entrenamiento de modelos
10.4.3. Optimización de gráficos con operaciones de TensorFlow
10.5. Carga y preprocesamiento de datos con TensorFlow
10.5.1. Carga de conjuntos de datos con TensorFlow
10.5.2. Preprocesamiento de datos con TensorFlow
10.5.3. Utilización de herramientas de TensorFlow para la manipulación de datos
10.6. La API tfdata
10.6.1. Utilización de la API tfdata para el procesamiento de datos
10.6.2. Construcción de flujos de datos con tfdata
10.6.3. Uso de la API tfdata para el entrenamiento de modelos
10.7. El formato TFRecord
10.7.1. Utilización de la API TFRecord para la serialización de datos
10.7.2. Carga de archivos TFRecord con TensorFlow
10.7.3. Utilización de archivos TFRecord para el entrenamiento de modelos
10.8. Capas de preprocesamiento de Keras
10.8.1. Utilización de la API de preprocesamiento de Keras
10.8.2. Construcción de pipelined de preprocesamiento con Keras
10.8.3. Uso de la API de preprocesamiento de Keras para el entrenamiento de modelos
10.9. El proyecto TensorFlow Datasets
10.9.1. Utilización de TensorFlow Datasets para la carga de datos
10.9.2. Preprocesamiento de datos con TensorFlow Datasets
10.9.3. Uso de TensorFlow Datasets para el entrenamiento de modelos
10.10. Construcción de una Aplicación de Deep Learning con TensorFlow
10.10.1. Aplicación Práctica
10.10.2. Construcción de una aplicación de Deep Learning con TensorFlow
10.10.3. Entrenamiento de un modelo con TensorFlow
10.10.4. Utilización de la aplicación para la predicción de resultados
Módulo 11. Deep Computer Vision con Redes Neuronales Convolucionales
11.1. La Arquitectura Visual Cortex
11.1.1. Funciones de la corteza visual
11.1.2. Teorías de la visión computacional
11.1.3. Modelos de procesamiento de imágenes
11.2. Capas convolucionales
11.2.1. Reutilización de pesos en la convolución
11.2.2. Convolución D
11.2.3. Funciones de activación
11.3. Capas de agrupación e implementación de capas de agrupación con Keras
11.3.1. Pooling y Striding
11.3.2. Flattening
11.3.3. Tipos de Pooling
11.4. Arquitecturas CNN
11.4.1. Arquitectura VGG
11.4.2. Arquitectura AlexNet
11.4.3. Arquitectura ResNet
11.5. Implementación de una CNN ResNet- usando Keras
11.5.1. Inicialización de pesos
11.5.2. Definición de la capa de entrada
11.5.3. Definición de la salida
11.6. Uso de modelos preentrenados de Keras
11.6.1. Características de los modelos preentrenados
11.6.2. Usos de los modelos preentrenados
11.6.3. Ventajas de los modelos preentrenados
11.7. Modelos preentrenados para el aprendizaje por transferencia
11.7.1. El Aprendizaje por transferencia
11.7.2. Proceso de aprendizaje por transferencia
11.7.3. Ventajas del aprendizaje por transferencia
11.8. Clasificación y Localización en Deep Computer Vision
11.8.1. Clasificación de imágenes
11.8.2. Localización de objetos en imágenes
11.8.3. Detección de objetos
11.9. Detección de objetos y seguimiento de objetos
11.9.1. Métodos de detección de objetos
11.9.2. Algoritmos de seguimiento de objetos
11.9.3. Técnicas de rastreo y localización
11.10. Segmentación semántica
11.10.1. Aprendizaje profundo para segmentación semántica
11.10.2. Detección de bordes
11.10.3. Métodos de segmentación basados en reglas
Módulo 12. Procesamiento del lenguaje natural (NLP) con Redes Naturales
Recurrentes (RNN) y Atención
12.1. Generación de texto utilizando RNN
12.1.1. Entrenamiento de una RNN para generación de texto
12.1.2. Generación de lenguaje natural con RNN
12.1.3. Aplicaciones de generación de texto con RNN
12.2. Creación del conjunto de datos de entrenamiento
12.2.1. Preparación de los datos para el entrenamiento de una RNN
12.2.2. Almacenamiento del conjunto de datos de entrenamiento
12.2.3. Limpieza y transformación de los datos
12.2.4. Análisis de Sentimiento
12.3. Clasificación de opiniones con RNN
12.3.1. Detección de temas en los comentarios
12.3.2. Análisis de sentimiento con algoritmos de aprendizaje profundo
12.4. Red de codificador-decodificador para la traducción automática neuronal
12.4.1. Entrenamiento de una RNN para la traducción automática
12.4.2. Uso de una red encoder-decoder para la traducción automática
12.4.3. Mejora de la precisión de la traducción automática con RNN
12.5. Mecanismos de atención
12.5.1. Aplicación de mecanismos de atención en RNN
12.5.2. Uso de mecanismos de atención para mejorar la precisión de los modelos
12.5.3. Ventajas de los mecanismos de atención en las redes neuronales
12.6. Modelos Transformers
12.6.1. Uso de los modelos Transformers para procesamiento de lenguaje natural
12.6.2. Aplicación de los modelos Transformers para visión
12.6.3. Ventajas de los modelos Transformers
12.7. Transformers para visión
12.7.1. Uso de los modelos Transformers para visión
12.7.2. Preprocesamiento de los datos de imagen
12.7.3. Entrenamiento de un modelo Transformers para visión
12.8. Librería de Transformers de Hugging Face
12.8.1. Uso de la librería de Transformers de Hugging Face
12.8.2. Aplicación de la librería de Transformers de Hugging Face
12.8.3. Ventajas de la librería de Transformers de Hugging Face
12.9. Otras Librerías de Transformers. Comparativa
12.9.1. Comparación entre las distintas librerías de Transformers
12.9.2. Uso de las demás librerías de Transformers
12.9.3. Ventajas de las demás librerías de Transformers
12.10. Desarrollo de una Aplicación de NLP con RNN y Atención. Aplicación Práctica
12.10.1. Desarrollo de una aplicación de procesamiento de lenguaje natural con RNN
y atención
12.10.2. Uso de RNN, mecanismos de atención y modelos Transformers en la aplicación
12.10.3. Evaluación de la aplicación práctica
Módulo 13. Autoencoders, GANs, y Modelos de Difusión
13.1. Representaciones de datos eficientes
13.1.1. Reducción de dimensionalidad
13.1.2. Aprendizaje profundo
13.1.3. Representaciones compactas
13.2. Realización de PCA con un codificador automático lineal incompleto
13.2.1. Proceso de entrenamiento
13.2.2. Implementación en Python
13.2.3. Utilización de datos de prueba
13.3. Codificadores automáticos apilados
13.3.1. Redes neuronales profundas
13.3.2. Construcción de arquitecturas de codificación
13.3.3. Uso de la regularización
13.4. Autocodificadores convolucionales
13.4.1. Diseño de modelos convolucionales
13.4.2. Entrenamiento de modelos convolucionales
13.4.3. Evaluación de los resultados
13.5. Eliminación de ruido de codificadores automáticos
13.5.1. Aplicación de filtros
13.5.2. Diseño de modelos de codificación
13.5.3. Uso de técnicas de regularización
13.6. Codificadores automáticos dispersos
13.6.1. Incrementar la eficiencia de la codificación
13.6.2. Minimizando el número de parámetros
13.6.3. Utilización de técnicas de regularización
13.7. Codificadores automáticos variacionales
13.7.1. Utilización de optimización variacional
13.7.2. Aprendizaje profundo no supervisado
13.7.3. Representaciones latentes profundas
13.8. Generación de imágenes MNIST de moda
13.8.1. Reconocimiento de patrones
13.8.2. Generación de imágenes
13.8.3. Entrenamiento de redes neuronales profundas
13.9. Redes adversarias generativas y modelos de difusión
13.9.1. Generación de contenido a partir de imágenes
13.9.2. Modelado de distribuciones de datos
13.9.3. Uso de redes adversarias
13.10. Implementación de los Modelos
13.10.1. Aplicación Práctica
13.10.2. Implementación de los modelos
13.10.3. Uso de datos reales
13.10.4. Evaluación de los resultados
Módulo 14. Computación bioinspirada
14.1. Introducción a la computación bioinspirada
14.1.1. Introducción a la computación bioinspirada
14.2. Algoritmos de adaptación social
14.2.1. Computación bioinspirada basada en colonia de hormigas
14.2.2. Variantes de los algoritmos de colonias de hormigas
14.2.3. Computación basada en nubes de partículas
14.3. Algoritmos genéticos
14.3.1. Estructura general
14.3.2. Implementaciones de los principales operadores
14.4. Estrategias de exploración-explotación del espacio para algoritmos genéticos
14.4.1. Algoritmo CHC
14.4.2. Problemas multimodales
14.5. Modelos de computación evolutiva (I)
14.5.1. Estrategias evolutivas
14.5.2. Programación evolutiva
14.5.3. Algoritmos basados en evolución diferencial
14.6. Modelos de computación evolutiva (II)
14.6.1. Modelos de evolución basados en estimación de distribuciones (EDA)
14.6.2. Programación genética
14.7. Programación evolutiva aplicada a problemas de aprendizaje
14.7.1. Aprendizaje basado en reglas
14.7.2. Métodos evolutivos en problemas de selección de instancias
14.8. Problemas multiobjetivo
14.8.1. Concepto de dominancia
14.8.2. Aplicación de algoritmos evolutivos a problemas multiobjetivo
14.9. Redes neuronales (I)
14.9.1. Introducción a las redes neuronales
14.9.2. Ejemplo práctico con redes neuronales
14.10. Redes neuronales (II)
14.10.1. Casos de uso de las redes neuronales en la investigación médica
14.10.2. Casos de uso de las redes neuronales en la economía
14.10.3. Casos de uso de las redes neuronales en la visión artificial
Módulo 15. Inteligencia Artificial: estrategias y aplicaciones
15.1. Servicios financieros
15.1.1. Las implicaciones de la Inteligencia Artificial (IA) en los servicios financieros.
Oportunidades y desafíos
15.1.2. Casos de uso
15.1.3. Riesgos potenciales relacionados con el uso de IA
15.1.4. Potenciales desarrollos / usos futuros de la IA
15.2. Implicaciones de la Inteligencia Artificial en el servicio sanitario
15.2.1. Implicaciones de la IA en el sector sanitario. Oportunidades y desafíos
15.2.2. Casos de uso
15.3. Riesgos Relacionados con el uso de la IA en el servicio sanitario
15.3.1. Riesgos potenciales relacionados con el uso de IA
15.3.2. Potenciales desarrollos / usos futuros de la IA
15.4. Retail
15.4.1. Implicaciones de la IA en Retail. Oportunidades y desafíos
15.4.2. Casos de uso
15.4.3. Riesgos potenciales relacionados con el uso de IA
15.4.4. Potenciales desarrollos / usos futuros de la IA
15.5. Industria
15.5.1. Implicaciones de la IA en la Industria. Oportunidades y desafíos
15.5.2. Casos de uso
15.6. Riesgos potenciales relacionados con el uso de IA en la Industria
15.6.1. Casos de uso
15.6.2. Riesgos potenciales relacionados con el uso de IA
15.6.3. Potenciales desarrollos / usos futuros de la IA
15.7. Administración Pública
15.7.1. Implicaciones de la IA en la Administración Pública. Oportunidades y desafíos
15.7.2. Casos de uso
15.7.3. Riesgos potenciales relacionados con el uso de IA
15.7.4. Potenciales desarrollos / usos futuros de la IA
15.8. Educación
15.8.1. Implicaciones de la IA en la educación. Oportunidades y desafíos
15.8.2. Casos de uso
15.8.3. Riesgos potenciales relacionados con el uso de IA
15.8.4. Potenciales desarrollos / usos futuros de la IA
15.9. Silvicultura y agricultura
15.9.1. Implicaciones de la IA en la silvicultura y la agricultura. Oportunidades y desafíos
15.9.2. Casos de uso
15.9.3. Riesgos potenciales relacionados con el uso de IA
15.9.4. Potenciales desarrollos / usos futuros de la IA
15.10. Recursos Humanos
15.10.1. Implicaciones de la IA en los Recursos Humanos. Oportunidades y desafíos
15.10.2. Casos de uso
15.10.3. Riesgos potenciales relacionados con el uso de IA
15.10.4. Potenciales desarrollos / usos futuros de la IA
